J’ai traité la part2 avec [ceci](https://www.ocf.berkeley.edu/~fricke/projects/hoshenkopelman/hoshenkopelman.html) que j’avais déjà utilisé dans [un autre projet](https://github.com/erik-adelbert/mcs/blob/master/pkg/chaingame/tag.go). Cet algorithme s’appuie sur un classique union-find ([ici](https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf), le cours de [sedgewick](https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist))) qui permet de remédier aux problèmes sur certains contours et avec les composants “concaves” engendrés par un `flooding nw`. Avec *Hoshen-Kopelman* on obtient la sortie parfaite sans pour autant faire exploser la complexité de l’algo (toutes les parties de l’algo sont linéaires en `n` avec `n` le nombre d’entrées) et surtout sans avoir à gérer une multitude de cas incroyables (impossible à mettre au point). Ma solution du jour pour part2 s'exécute en temps linéaire \o/
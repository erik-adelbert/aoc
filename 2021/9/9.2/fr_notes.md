J’ai traité la part2 avec [ceci](https://www.ocf.berkeley.edu/~fricke/projects/hoshenkopelman/hoshenkopelman.html) que j’avais déjà utilisé dans [un autre projet](https://github.com/erik-adelbert/mcs/blob/master/pkg/chaingame/tag.go). Cet algorithme s’appuie sur un classique union-find ([ici](https://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf), le cours de sedgewick) qui permet de remédier aux problèmes sur certains contours et avec les composants “concaves” engendrés par un `flooding nw`. Avec *Hoshen-Kopelman* on obtient la sortie parfaite sans pour autant faire exploser la complexité de l’algo (toutes les parties de l’algo sont linéaires en n avec n le nombre d’entrées) et surtout sans avoir à gérer une multitude de cas incroyables (impossible à mettre au point). Du coup, ma solution du jour pour part2 est linéaire et s’exécute en 1ms sur mes inputs \o/
```❯ time bash run.sh 2000 "cat input.txt" > /dev/null
bash run.sh 2000 "cat input.txt" > /dev/null  0.87s user 2.14s system 139% cpu 2.157 total
❯ time bash run.sh 2000 ./aoc9.2 > /dev/null
bash run.sh 2000 ./aoc9.2 > /dev/null  2.44s user 2.79s system 121% cpu 4.315 total
❯ echo "(4.315 - 2.157) / 2000" | bc -l
.00107900000000000000```